# -*- coding: utf-8 -*-
"""Optic Disc Segmentation in Fundus Image.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BW-u5tJu_IKPbdMaBBYAQhIkl8pW5B3I

#Optic Disc Segmentation in Fundus Image using Blue Channel and Simple Thresholding Method

### Extract ZIP
"""

import zipfile as zf
files = zf.ZipFile("images.zip", 'r')
files.extractall('directory to extract')
files.close()

!pip install patool
import patoolib

"""Download **patool** to open ZIP file"""

patoolib.extract_archive('images.zip')

"""Using ```patoolib.extract_archive()``` to unzip file **images.zip** """

pip install opencv-python

"""Install library **opencv-python**  """

import numpy as np
from PIL import Image as im
import glob
import cv2
import matplotlib.image as mpimg
import matplotlib.pyplot as plt

"""# Import 650 Image into 1 variabel

Import library **numpy, PIL, glob, cv2, matplotlib.image, dan matplotlib.pyplot**
"""

file = 'C:\\Users\\ASUS\\4 TPCB\\images1\\images\\*.jpg'
image = cv2.imread(file)
glob.glob(file)

"""- Reading image inside file **images**
- Available 650 images inside file (.jpg)
"""

all_images = [cv2.imread(image) for image in glob.glob(file)]

type(all_images)

len(all_images)

"""# Color Channel Image"""

image = cv2.imread('C:\\Users\\ASUS\\4 TPCB\\images1\\images\\1.jpg')
img = Image.fromarray(image)
img.mode

"""# Compare Color Channel (Image 1, 30, dan 650)"""

image1 = cv2.imread('C:\\Users\\ASUS\\4 TPCB\\images1\\images\\1.jpg')
image30 = cv2.imread('C:\\Users\\ASUS\\4 TPCB\\images1\\images\\30.jpg')
image650 = cv2.imread('C:\\Users\\ASUS\\4 TPCB\\images1\\images\\650.jpg')

"""Red Channel"""

red, green, blue = cv2.split(image1)
red = cv2.cvtColor(red, cv2.COLOR_BGR2RGB)
plt.title('Red Channel Image 1')
plt.imshow(red)
plt.show()

red, green, blue = cv2.split(image30)
red = cv2.cvtColor(red, cv2.COLOR_BGR2RGB)
plt.title('Red Channel Image 30')
plt.imshow(red)
plt.show()

red, green, blue = cv2.split(image650)
red = cv2.cvtColor(red, cv2.COLOR_BGR2RGB)
plt.title('Red Channel Image 650')
plt.imshow(red)
plt.show()

"""Green Channel"""

red, green, blue = cv2.split(image1)
green = cv2.cvtColor(green, cv2.COLOR_BGR2RGB)
plt.title('Green Channel Image 1')
plt.imshow(green)
plt.show()

red, green, blue = cv2.split(image30)
green = cv2.cvtColor(green, cv2.COLOR_BGR2RGB)
plt.title('Green Channel Image 30')
plt.imshow(green)
plt.show()

red, green, blue = cv2.split(image650)
green = cv2.cvtColor(green, cv2.COLOR_BGR2RGB)
plt.title('Green Channel Image 650')
plt.imshow(green)
plt.show()

"""Blue Channel"""

red, green, blue = cv2.split(image1)
blue = cv2.cvtColor(blue, cv2.COLOR_BGR2RGB)
plt.title('Blue Channel Image 1')
plt.imshow(blue)
plt.show()

red, green, blue = cv2.split(image30)
blue = cv2.cvtColor(blue, cv2.COLOR_BGR2RGB)
plt.title('Green Channel Image 30')
plt.imshow(blue)
plt.show()

red, green, blue = cv2.split(image650)
blue = cv2.cvtColor(blue, cv2.COLOR_BGR2RGB)
plt.title('Green Channel Image 650')
plt.imshow(blue)
plt.show()

"""- Red channel not display dominant optic disc for segmentation
- Green channel utilize at display blood vessels
-  **Blue Channel** is the dominant one

# Split Color Channel
"""

for i in all_images:
        red, green, blue = cv2.split(i)
        blue = cv2.cvtColor(blue, cv2.COLOR_BGR2RGB)
        plt.imshow(blue)
        plt.show()

"""- Using **for** to split the RGB color channel into **red**, **green**, and **blue**
- We will take the blue channel because the optic disc is dominant for image enhancement and segmentation.
- The blue display image ranges from 1 to 650.

# Gaussian Filter
"""

import skimage.io
import skimage.color
import skimage.filters

"""Import library **skimage** """

for i in all_images:
    red, green, blue = cv2.split(i)
    blue = cv2.cvtColor(blue, cv2.COLOR_BGR2RGB)
    
    # Mengubah citra ke bentuk grayscale
    blue = skimage.color.rgb2gray(blue)

    # Blur citra untuk denoise
    blue = skimage.filters.gaussian(blue, sigma=1.0)

    plt.imshow(blue, cmap='gray')
    plt.show()

"""Using **Gaussian Filter** to give blurry effect in image that can reduce  **speckle noise**

# Simple Thresholding
"""

for i in all_images:
    red, green, blue = cv2.split(i)
    blue = cv2.cvtColor(blue, cv2.COLOR_BGR2RGB)
    
    # Mengubah citra ke bentuk grayscale
    blue = skimage.color.rgb2gray(blue)

    # Blur citra untuk denoise
    blue = skimage.filters.gaussian(blue, sigma=1.0)
    
    # Buat mask berdasarkan ambang batas
    t = 0.97
    blue = blue < t

    fig, ax = plt.subplots()
    plt.imshow(blue, cmap='gray')
    plt.show()

"""**Simple Thresholding** with **t = 0,97** to display optic disc that seperate with background

# Ground Truth (.mat)

First, convert ground truth image into (.png). Then compare image number 1, 30, and 650
"""

marking_1 = cv2.imread("C:\\Users\\ASUS\\4 TPCB\\marking1.jpg")
plt.title('Manual Marking 1')
plt.imshow(marking_1)
plt.show()

marking_30 = cv2.imread("C:\\Users\\ASUS\\4 TPCB\\manual30.jpg")
plt.title('Manual Marking 30')
plt.imshow(marking_30)
plt.show()

marking_650 = cv2.imread("C:\\Users\\ASUS\\4 TPCB\\manual650.jpg")
plt.title('Manual Marking 650')
plt.imshow(marking_650)
plt.show()

"""Second, the image result still dark, then do image enhancment  **brightness** with factor 20"""

from PIL import Image, ImageEnhance

"""Import library PIL """

#Read Image
im1 = Image.open("C:\\Users\\ASUS\\4 TPCB\\marking1.jpg")

# Add brightness
enhancer = ImageEnhance.Brightness(im1)

# Factor 20
factor = 20
im_output1 = enhancer.enhance(factor)
plt.title('Manual Marking 1')
plt.imshow(im_output1, cmap='gray')
plt.show()

#Read Image
im30 = Image.open("C:\\Users\\ASUS\\4 TPCB\\manual30.jpg")

# Add brightness
enhancer = ImageEnhance.Brightness(im30)

# Factor 20
factor = 20
im_output30 = enhancer.enhance(factor)
plt.title('Manual Marking 30')
plt.imshow(im_output30, cmap='gray')
plt.show()

#Read Image
im650 = Image.open("C:\\Users\\ASUS\\4 TPCB\\manual650.jpg")

# Add brightness
enhancer = ImageEnhance.Brightness(im650)

# Factor 20
factor = 20
im_output650 = enhancer.enhance(factor)
plt.title('Manual Marking 650')
plt.imshow(im_output650, cmap='gray')
plt.show()

"""# Ground Truth Evaluation"""

segmentasi1 = cv2.imread("C:\\Users\\ASUS\\4 TPCB\\image1_segmentasi.png")
segmentasi30 = cv2.imread("C:\\Users\\ASUS\\4 TPCB\\image30_segmentasi.png")
segmentasi650 = cv2.imread("C:\\Users\\ASUS\\4 TPCB\\image650_segmentasi.png")

fig, ax = plt.subplots(1, 2, figsize=(13,13))
ax[0].set_title(f'Hasil Segmentasi Image 1', fontsize = 15)
ax[0].imshow(segmentasi1, cmap='gray')
ax[0].set_axis_off()
ax[1].set_title(f'Manual Marking Image 1', fontsize = 15)
ax[1].imshow(im_output1 , cmap='gray')
ax[1].set_axis_off()

fig, ax = plt.subplots(1, 2, figsize=(13,13))
ax[0].set_title(f'Hasil Segmentasi Image 30', fontsize = 15)
ax[0].imshow(segmentasi30, cmap='gray')
ax[0].set_axis_off()
ax[1].set_title(f'Manual Marking Image 30', fontsize = 15)
ax[1].imshow(im_output30 , cmap='gray')
ax[1].set_axis_off()

fig, ax = plt.subplots(1, 2, figsize=(13,13))
ax[0].set_title(f'Hasil Segmentasi Image 650', fontsize = 15)
ax[0].imshow(segmentasi650, cmap='gray')
ax[0].set_axis_off()
ax[1].set_title(f'Manual Marking Image 650', fontsize = 15)
ax[1].imshow(im_output650 , cmap='gray')
ax[1].set_axis_off()

"""**Evaluasi**

- Compare the image results of 1, 30, and 650 with manual marking.
- We obtained image results similar to the segmentation image when using manual marking.
- The experiment was a success. However, some images still had noise due to different conditions in the eye that were captured in the fundus image.
"""